<!DOCTYPE HTML>
<html>
  <head>
    <title>Exam 1 Review</title>
  </head>

  <body>
    <h1>Exam 1 Review</h1>
    <h2>Data Representation</h2>
    <ol>
      <li><p>Convert the decimal number 39 into 8-bit binary.</p><p>00100111</p></li>
      <li><p>Convert the decimal number 40 into a two-digit hexadecimal number.</p><p>0x28</p></li>
      <li><p>Convert the hexadecimal number <code>0x45</code> into decimal.</p><p>69</p></li>
      <li><p>Convert the hexadecimal number <code>0x1F</code> into decimal.</p><p>31</p></li>
      <li><p>Convert the <b>unsigned</b> binary number <code>1001</code> into decimal.</p><p>9</p></li>
      <li><p>Convert the <b>signed</b> binary number <code>1001</code> into decimal.</p><p>-7</p></li>
      <li><p>Convert -5 into binary, using two's complement.</p><p>1011</p></li>
      <li><p>Negate the number 7 using two's complement, and show its 4-bit binary representation.</p><p>1001</p></li>
      <li><p>Negate the binary number <code>0110</code> using two's complement, showing the result in binary.</p><p>1010</p></li>
      <li><p>What's the quickest way to tell if a number in two's complement is negative?</p><p>It is negative if its left-most bit is a 1.</p></li>
      <li>
        <p>In 5 bits, what is the most <b>negative</b> value representable in <b>signed</b> form, using two's complement?
        Express your answer in both binary and decimal.</p>
        <ul>
          <li>Binary: 10000</li>
          <li>Decimal: -16</li>
        </ul>
      </li>
      <li>
        <p>In 5 bits, what is the most <b>positive</b> value representable in <b>signed</b> form, using two's complement?
        Express your answer in both binary and decimal.</p>
        <ul>
          <li>Binary: 01111</li>
          <li>Decimal: 15</li>
        </ul>
      </li>
      <li>
        <p>In 5 bits, what is the most <b>negative</b> value representable in <b>unsigned</b> form?
        Express your answer in both binary and decimal.</p>
        <p>You cannot represent a negative value in unsigned form; unsigned form means that all
        the bits are used for representing positive values.</p>
      </li>
      <li>
        <p>In 5 bits, what is the most <b>positive</b> value representable in <b>unsigned</b> form?
        Express your answer in both binary and decimal.</p>
        <ul>
          <li>Binary: 11111</li>
          <li>Decimal: 31</li>
        </ul>
      </li>
      <li>
        <p>
          Suppose you are given the following 4-bit binary number, shown in two's complement:
          <pre><b>0110</b></pre>
          You're not told whether or not the number is signed or unsigned.
          Is this information important in knowing what the value of the number is, in decimal?
          That is, do you need to know if it's signed or unsigned to say what the decimal value is?
          Why or why not?
        </p>
        <p>
          First of all, we know that it's signed because it's in two's complement.
          However, even we hadn't been told that it's in two's complement and only been told it's a binary
          number, we wouldn't need to be told if it's signed or not because the left-most bit is a 0, meaning
          it will be positive a number regardless of whether the number was signed or unsigned.
          It is equal to 6 decimal in either case.
        </p>
      </li>
      <li>
        <p>
          Suppose you are given the following 4-bit binary number, shown in two's complement:
          <pre><b>1001</b></pre>
          You're not told whether or not the number is signed or unsigned.
          Is this information important in knowing what the value of the number is, in decimal?
          That is, do you need to know if it's signed or unsigned to say what the decimal value is?
          Why or why not?
        </p>
        <p>
          Like the previous question, we know it's signed because it's in two's complement.
          If we hadn't been told it was two's complement, then because of the left-most bit being a 1,
          we would be unable to determine the value of the number unless more information was given.
          This is because the left-most bit would make it a negative number if the number was signed,
          and a different positive number if the number was unsigned.
        </p>
      </li>
    </ol>

    <h2>Binary Arithmetic</h2>
    <ol>
      <li>
        <p>
          Suppose that a binary addition was performed in a processor, and the processor set the <b>carry</b> bit at the end of the computation.
          What does this mean?
          That is, what is the significance of the carry bit being set after an addition is performed?
        </p>
        <p>
          After addition, the carry bit being set means that the result of the addition did not fit into the number of bits alloted.
          For example, adding two <b>unsigned 4-bit</b> binary numbers 5 and 11:
          <pre>
  0101
+ 1011
------
 10000
          </pre>
          Notice that the result is 5 bits wide, but we only have <b>4 bits</b> to store the number in.
          Therefore, the result of the additon is actually <pre>0000</pre> with a carry set (the carry corresponding to the bit that would have been in position 4 if we had a 5 bits available).
        </p>
      </li>
      <li>
        <p>
          Suppose that a binary addition was performed in a processor, and the processor set the <b>overflow</b> bit at the end of the computation.
          What does this mean?
          That is, what is the significance of the overflow bit being set after an addition is performed?
        </p>
        <p>
        After addition, the overflow bit being set means that the result of adding two same-signed numbers resulted in a number of a different sign
        (just like in decimal, if you add two positive numbers, you must get a positive number, and if you add two negative numbers, you must get a
        negative number).
        For example, here we add two <b>signed 4-bit</b> binary numbers 5 and 7:
        <pre>
  0101
+ 0111
------
  1100
        </pre>
        The resulting number, because we are dealing with signed numbers, is not 12 as it should be, but is instead -4 (because of two's complement).
        Both numbers were positive, but we got a negative result, thus we have overflow.
      </li>
      <li>
        <p>
          Generally, the <b>carry</b> bit is ignored when performing <b>signed</b> arithmetic.
          Why?
        </p>
        <p>
          The carry bit is used to signify that we do not have enough bits to represent the result of a computation using <b>unsigned</b> arithmetic, and doesn't correspond to anything interesting in a signed setting.
        </p>
      </li>
      <li>
        <p>
          Generally, the <b>overflow</b> bit is ignored when performing <b>unsigned</b> arithmetic.
          Why?
        </p>
        <p>
          The overflow bit is set when the two inputs have the same sign, but the output lacks this same sign.
          In an unsigned setting, because there are no such things as negative numbers, this distinction is meaningless.
        </p>
      </li>
      <li>
        <p>Perform the following two's complement <b>addition</b>, noting whether or not the carry bit (C) and/or the overflow bit (V) get set:</p>
<pre>
 01111111
+11111111
---------
 01111110 C
</pre>
      </li>
      <li>
        <p>Perform the following two's complement <b>addition</b>, noting whether or not the carry bit (C) and/or the overflow bit (V) get set:</p>
<pre>
 00100101
+10110111
---------
 11011100
</pre>
      </li>
      <li>
        <p>Perform the following two's complement <b>subtraction</b>, noting whether or not the carry bit and/or the overflow bit get set:</p>
<pre>
 01111111
-11111111
---------
 10000000 V
</pre>
      </li>
      <li>
        <p>Perform the following two's complement <b>subtraction</b>, noting whether or not the carry bit and/or the overflow bit get set:</p>
<pre>
 00100101
-10110111
---------
 01101110
</pre>
      </li>
      <li>
        <p>Consider the following C code:</p>
<pre>
signed char x;          
for (x = 1; x > 0; x++) {
  printf("Hello\n");
}
printf("Goodbye\n");
</pre>
        <p>
          Assume the compiler performs a naive translation to assembly, and doesn't exploit any special features of C. Recall that <code>char</code> in C is represented with 1 byte. Does <code>"Goodbye\n"</code> ever get printed out? Why or why not?
        </p>
            <p>
              <code>"Goodbye\n"</code> <b>will</b> be printed out. Since a <code>char</code> is represented with one 8-bit byte,
              the initial value of <code>x</code> will be 1, and then <code>x</code> is incremented continually. It will eventually reach the largest positive 8-bit
              number, which, because this is signed two's complement, is (2^8)-1, 127 in decimal, or <code>01111111</code> in binary. Adding one
              more to that results in <code>10000000</code> (binary), which is -128. Since -128 is less than 0, it finally exits the loop and prints
              the final <code>"Goodbye\n"</code>.
            </p>
      </li>
      <li>
        <p>
          Consider the following C code:
        </p>
<pre>
unsigned char x;
for (x = 0; x &lt;= MAX_UNSIGNED_CHAR; x++) {
  printf("Hello\n");
}
printf("Goodbye\n");
</pre>
        <p>
          Assume that <code>MAX_UNSIGNED_CHAR</code> holds the maximum value representable in an <code>unsigned char</code>, which is defined previously in the code. Does <code>"Goodbye\n"</code> ever get printed out?</li></p>
            <p>
            The word <code>"Goodbye\n"</code> will <b>never</b> get printed out. A character is represented using 8 bits, and because <code>x</code> is unsigned,
            it will be incremented until it reaches it's largest value, which is 1111111 in binary (255 in decimal), which is also equal to <code>MAX_UNSIGNED_CHAR</code>.
            When you add one to the largest unsigned 8-bit value, it wraps around back to 0 and continues incrementing, forever. Thus, the comparison <code>x &lt;= MAX_UNSIGNED_CHAR</code>
            will stay true for any of the possible values <code>x</code> gets.
            </p>
        </li>
    
    <h2>Bitwise Operations</h2>
    <p>
      In the following questions, <code>&amp;</code> refers to bitwise AND, <code>|</code> refers to bitwise OR, <code>^</code> refers to bitwise XOR, <code>&lt;&lt;</code> refers to shift left, and <code>&gt;&gt;</code> refers to shift right.
    </p>
    
    <ol>
      <li>
        What is the result of the following operation:
<pre>
 00011101
&amp;11011010
---------
 00011000
</pre>
      </li>
      <li>
        What is the result of the following operation:
<pre>
 00011101
|11011010
--------- 
 11011111
</pre>
      </li>
      <li>
        What is the result of the following operation:
<pre>
 00011101
^11011010
--------- 
 11000111
</pre>
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the lowest 7 bits of the given input <code>i</code>, leaving the bits in their original position:</p>
<pre>
int unsignedBits0through6(int i) {
  return __________;
}
</pre>
        <p>Fill in <code>__________</code> with a <b>single bitwise expression</b> which will make the code do what it is intended to do.</p>
<pre>
(i &amp; 0x0000007F)
</pre>          
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the next 7 bits of the given input <code>i</code>, leaving the bits in their original position:</p>
<pre>
int unsignedBits7through13(int i) {
  return __________;
}
</pre>
        <p>Fill in <code>__________</code> with a <b>single bitwise expression</b> which will make the code do what it is intended to do.</p>
<pre>
(i &amp; 0x00003F80)
</pre>          
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the lowest 7 bits of the given input <code>i</code>, treating the result as a <b>signed</b> value, leaving the bits in their original position:</p>
<pre>
int signedBits0through6(int i) {
  __________;  
  return __________;
}
</pre>
        <p>Fill in the blanks with valid C code which will make the function do what it is intended to do.</p>
<pre>
int signedBits0through6(int i) {
  int u = i &amp; 0x0000007F;
  if (u &amp; 0x00000040) {
    u |= 0xFFFFFF80;
  }
  return u;
}
</pre>
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the next 7 bits of the given input <code>i</code>, treating the result as a <b>signed</b> value, putting the bits in the rightmost position:</p>
<pre>
int signedBits7through13(int i) {
  __________;  
  return __________;
}
</pre>
        <p>Fill in the blanks with valid C code which will make the function do what it is intended to do.</p>
<pre>
int signedBits7through13(int i) {
  int u = (i &amp; 0x00003F80) &gt;&gt; 7;
  if (u &amp; 0x00000040) {
    u |= 0xFFFFFF80;
  }
  return u;
}
</pre>
      </li>
      <li>
        <p>
        Consider the binary value <code>00001011</code>, stored in <code>$s0</code>.
        How can this be <b>multiplied</b> by 4, <b>without</b> using an instruction intented for division or multiplication?
        </p>
<pre>
sll $s0, $s0, 2
</pre>
      </li>
      <li>
        <p>
        Consider the <b>signed</b> binary value <code>00001011</code>, stored in <code>$s0</code>.
        How can this be <b>divided</b> by 4, <b>without</b> using an instruction intented for division or multiplication?
        </p>
<pre>
sra $s0, $s0, 2
</pre>  
      </li>
      <li>
        <p>
          There is only one form of shift left, but there are two forms of shift right.
          Some questions follow about this fact:
        </p>
        <ol>
          <li>
            <p>Why are there two forms of shift right?</p>
            <p>
              One is for signed values in two's complement, and the other for unsigned values.
              For example, consider the following 4-bit number:
            </p>
<pre>
1011
</pre>
            <p>
              Let's say we shift right two places, like so:
            </p>
<pre>
XX10
</pre>
            <p>
              ...where <code>XX</code> are the two bit positions on the left we need to fill in.
              If the original value was unsigned, then we should always fill in with zeros.
              However, if the value was signed, then we'd potentially have a problem if we're using shift right to divide: if we only fill in zeros, then the number becomes positive.
              That is, we could end up getting a positive result back if we divide a negative number by a positive number, which wouldn't be correct.
              To address this problem, there is a version of shift right (arithmetic shift right) which will fill in the <code>XX</code>'s above with whatever the leftmost bit remaining is (in this case, <code>1</code>).
              In summary, this means that the non-arithmetic version of shift right always fills in zeros on the left (resulting in <code>0010</code> in the above example), and the arithmetic version fills in whatever bit preserves the signedness of the original value (resulting in <code>1110</code> in the above example).
            </p>
          </li>
          <li>
            <p>What do the two different forms of shift right do?</p>
            <p>Fill in higher order bits with 0s or 1s, according to the mechanism described in the previous answer..</p>
          </li>
          <li>
            <p>Why is there only one form of shift left?</p>
            <p>
              There are no leftmost bits to fill in.
              Substituting zeros on the right is the correct behavior regardless of the signedness of the value.
            </p>
          </li>
        </ol>
      </li>
      <li>
        <p>
          Division by a power of two can be achieved via the clever use of shift right.
          However, this won't always get the same result as actual division would.
          Some questions follow about these facts:
        </p>
        <ol>
          <li>
            <p>Under what conditions will shift right and division not return the same result?</p>
            <p>
              When the dividend is negative.
            </p>
          </li>
          <li>
            <p>
              The difference in results is viewable in a difference between rounding.
              What is the difference in rounding here?
            </p>
            <p>
              Integer division rounds towards zero, whereas shift right rounds towards negative infinity.
              When dealing with positive values, this distinction is meaningless, as there is no situation under which the behavior is different.
              However, with negative values, this causes problems.
              To demonstrate, consider <code>-5 / 2</code>.
              Mathematically, this results in <code>-2.5</code>.
              Using integer division gets <code>-2</code>, but using shift right on the equivalent binary values results in <code>-3</code>.
            </p>
          </li>
        </ol>
      </li>
    </ol>
    
    <h2>Assembly</h2>
    <ol>
      <li>
        <p>What does the <code>li</code> pseudoinstruction do?</p>
        <p>
          It loads the immediate value (2nd operand) into the target register (first operand).
          For example:
        </p>
<pre>
li $t0, 7
</pre>
        <p>...puts the value of <code>7</code> into register <code>$t0</code>.</p>
      </li>
      <li>
        <p>Why isn't <code>li</code> an actual MIPS instruction?</p>
        <p>
          All MIPS instructions are exactly 32 bits large.
          <code>li</code> can be used to load a 32 bit constant into a register.
          Therein lies a problem: the constant's entire value couldn't possibly be held in a single instruction, because there aren't enough bits (in addition to the 32 bits of the constant, there would need to be other bits to encode what the instruction is, which requires in total more than 32 bits).
          It is for this reason that <code>li</code> is a psuedoinstruction which can be automatically translated to <i>multiple</i> instructions, whenever we need to specify a constant using the full 32 bits.
        </p>
      </li>
      <li>
        Translate the following MIPS code using <code>li</code> to a form that uses only actual instructions (no pseudoinstructions):
<pre>
li $t0, 0xFFFFFFFF

# is translated into:
lui $t0, 0xFFFF
ori $t0, $t0, 0xFFFF
</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0 = 82;
int s1 = s0 &lt;&lt; 2;
int s2 = s1 * 20;
int s3 = s2 + 7;
int s4 = s3 - 24;
int s5 = s4 / 3;

main:
  li $s0, 82         # int s0 = 82;

  sll $s1, $s0, 2    # int s1 = s0 &lt;&lt; 2;

  li $t0, 20         # int s2 = s1 * 20 (part 1 of 3)
  mult $s1, $t0      #                  (part 2 of 3)
  mflo $s2           #                  (part 3 of 3)


  addi $s3, $s2, 7   # int s3 = s2 + 7

  li $t1, 24         # int s4 = s3 - 24 (part 1 of 2)
  sub $s4, $s3, $t1  #                  (part 2 of 2)

  li $t2, 3          # int s5 = s4 / 3 (part 1 of 3)
  div $s4, $t2       #                 (part 2 of 3)
  mflo $s5           #                 (part 3 of 3)

</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          Where <code>&lt;&lt;read integer from the user&gt;&gt;</code> is used, you should use special functionality provided by SPIM to read in an integer from the console.
          Where <code>&lt;&lt;print integer s1&gt;&gt;</code> is used, you should use special functionality provided by SPIM to print the integer stored in <code>s1</code> to the console (you might not be able to do this directly, in which case you'll need to copy the value of <code>s1</code> into another register first).
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0 = &lt;&lt;read integer from the user&gt;&gt;;
int s1 = 2;  
if (s0 &lt; 7) {
  s1 = 3;
}
&lt;&lt;print integer s1&gt;&gt;

main:
  # read integer from user
  li $v0, 5
  syscall

  # save integer from user
  move $s0, $v0

  # store 2 in s1
  li $s1, 2

  # check if s0 &lt; 7
  li $t0, 7
  slt $t1, $s0, $t0

  # if it's NOT less than 7, skip the body of the if
  beq $t1, $zero, printmsg

  # we didn't branch, meaning s0 &lt; 7
  li $s1, 3

printmsg:
  # print s1
  li $v0, 1
  move $a0, $s1
  syscall

</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          Where <code>&lt;&lt;read integer from the user&gt;&gt;</code> is used, you should use special functionality provided by SPIM to read in an integer from the console.
          Where <code>&lt;&lt;print integer s1&gt;&gt;</code> is used, you should use special functionality provided by SPIM to print the integer stored in <code>s1</code> to the console (you might not be able to do this directly, in which case you'll need to copy the value of <code>s1</code> into another register first).
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0 = &lt;&lt;read integer from the user&gt;&gt;;
int s1 = 2;  
if (s0 &lt; 7) {
  s1 = 3;
} else {
  s1 = s0 + s0;
}         
&lt;&lt;print integer s1&gt;&gt;

main:
  # read in the integer from the user, and initialize s1
  li $v0, 5
  syscall
  move $s0, $v0
  li $s1, 2

  # check if $s0 < 7
  li $t0, 7
  slt $t1, $s0, $t0

  # jump to the else branch if this isn't true
  beq $t1, $zero, else_branch                 

  # fall through to the true branch
  li $s1, 3                  
  j print

else_branch:
  add $s1, $s0, $s0
  # fall through to the print

print:
 li $v0, 1
 move $a0, $s0                  
 syscall									
</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0;
int s1 = 1;  
for (s0 = 0; s0 &lt; 10; s0++) {
  s1 = s1 * s0;
}

main:
  # initialize variables
  li $s0, 0
  li $s1, 2
loop:
  # check loop condition
  li $t0, 10
  slt $t1, $s0, $t0          # s0 < 10?
  beq $t1, $zero, loop_exit  # if not, jump to loop_exit

  # do body of the loop                                    
  mult $s1, $s0
  mflo $s1

  # increment counter                                    
  addi $s0, $s0, 1
  j loop
                                    
loop_exit:
  # this is past the loop
</pre>
      </li>
    </ol>
  </body>
</html>
